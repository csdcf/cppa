/******************************************************************************
cppa.c -- CPP Assistant
$Id: cppa.c 2717 2011-06-20 17:49:43Z miles $
$Source$

This program is used to assist the C preprocessor (cpp) in processing text 
files.  It:
1. Allows macro expansion within quotes.
2. Fixes the handling of blank lines.
3. Using the "make" option, it can automatically generate a .make file.

See also the other cppa modules such as cppa-make.c, cppa-pre.c, 
and cppa-post.c.

See usage string below for usage hint.
See the Help() procedure for more usage and history information.

Use cppa.make to compile the program.  E.g.
    Sunburn> make -f cppa.make
******************************************************************************/
#define MODULE_MAIN
#include "cppa.h"

/* Variables used to extract lines and symbols from the input file */

int line_cnt = 0;
int lindex;
char line[LINE_CHARS_MAXCNT];



/******************************************************************************
String Constants
******************************************************************************/

char rcs_id[] = "$Id: cppa.c 2717 2011-06-20 17:49:43Z miles $";

char usage[] = "Usage: \n\
\n\
    cppa\n\
\n\
 -- OR --\n\
\n\
    cppa help | more\n\
\n\
 -- OR --\n\
\n\
    cppa pre name.cppa | cpp -C -P -D_version | cppa post > name.version\n\
\n\
 -- OR --\n\
\n\
    cppa make name.cppa > name.make\n\
    make -f name.make\n\
\n\
";

char help_1[] = "\n\
\n\
cppa -- 'CPP Assist'  --  Report problems to albert@cs.Stanford.EDU\n\
\n\
The cppa program is used in conjunction with the cpp program.  Normal cpp\n\
directives work plus there are extra directives that may be used with cppa.\n\
\n\
SIMPLE USAGE (Level 1)\n\
======================\n\
\n\
In the simplest case, there are two or more versions of a file that we wish \n\
to generate from one source file.  For example, suppose we wish to create two \n\
versions of an introductory manual.  We can call these versions 'intro.staff'\n\
and 'intro.student'.  We wish to edit only one file called 'intro.cppa' and\n\
have the changes appear in both of the versions.  We edit intro.cppa and\n\
use cpp directives such as '#ifdef _STAFF', '#ifdef _STUDENT', and '#endif'\n\
to define which lines go into which version.  (See the man pages for the\n\
cpp UNIX utility for more information about cpp directives.)  When we are\n\
ready, we can generate the two versions using these commands:\n\
\n\
    %% cppa pre intro.cppa | cpp -C -P -D_STAFF   | cppa post > intro.staff\n\
    %% cppa pre intro.cppa | cpp -C -P -D_STUDENT | cppa post > intro.student\n\
\n\
This can easily be extended for more than two versions.\n\
\n\
cppa takes care of fixing quotes and removing excessive blank lines that are \n\
generated by cpp.  cpp handles the conditional cpp directives such as '#ifdef'.\n\
\n\
";


char help_2[] = "\
AUTOMATIC MAKE FILE GENERATION (Level 2)\n\
========================================\n\
\n\
cppa can automatically generate a make file which can be used to generate\n\
all versions of a file.  In order for this to work, the .cppa file must\n\
contain one line of the following format for each version to be created:\n\
\n\
    #cppa target <target-file> [<define>...]\n\
\n\
Replace '<target-file>' with the name of the file which will contain the\n\
version.  Replace '[<define>...]' with one or more cpp variables which are\n\
to be set when making this version.\n\
\n\
For the example above, we would add the following lines:\n\
\n\
    #cppa target intro.staff _STAFF\n\
    #cppa target intro.student _STUDENT\n\
\n\
After we are done editing the intro.cppa file, we can generate intro.make and\n\
all the variations by doing:\n\
\n\
    %% cppa make intro.cppa > intro.make\n\
    %% make -f intro.make\n\
\n\
After we have done this once, we can do just one line to rebuild everything:\n\
\n\
    %% make -f intro.make\n\
\n\
This saves quite a bit of typing.  (cppa assumes that the cppa file name and \n\
the make file are different only in the suffix (.cppa and .make).)\n\
\n\
";

char help_3[] = "\\n\
COMPLEX MAKEFILE GENERATION (Level 3)\n\
=====================================\n\
\n\
For the dedicated user, these features can be used to customize the .make file\n\
produced by the program:\n\
\n\
  #cppa makenoshowtarget\n\
  #cppa makeheader\n\
  #cppa maketopdep [<additions>]\n\
  #cppa maketopcmds\n\
  #cppa makemake\n\
  #cppa makebody\n\
  #cppa makelines\n\
  [<lines to be inserted in current position>]\n\
  #cppa endmakelines\n\
\n\
makelines/endmakelines can be inserted between any of the other cppa make*\n\
directives.  The other cppa make* directives should be used in the order shown.\n\
\n\
makenoshowtarget will cause the make file to NOT include lines that display the\n\
  target which is being made\n\
\n\
makeheader will cause a makefile header to be included at the current\n\
  position in the standard output.  \n\
maketopdep makes the top dependency line for the makefile.\n\
maketopcmds makes the commands that follow the top dependency line.\n\
makemake adds lines for updating the make file automatically.\n\
makebody will cause the CPPA targets to be included in the current position.\n\
makelines will cause the specified lines to be included in current position.\n\
\n\
\n\
";





char help_addl[] = "\n\
ADDITIONAL FEATURES (All Levels)\n\
================================\n\
\n\
Comments\n\
--------\n\
\n\
    #cppa comment\n\
    [<comment lines>]\n\
    #cppa endcomment\n\
\n\
Comments can be put into the .cppa files by surrounding them by special cppa\n\
directives that were created for this purpose.  Use '#cppa comment' before\n\
the comment lines.  Use '#cppa endcomment' after the comment lines.\n\
The cppa directives and the comments lines will be left out of the output\n\
files.\n\
\n\
Do not edit\n\
-----------\n\
\n\
    #cppa dne\n\
\n\
A 'DO NOT EDIT' message can be put into the output file using the '#cppa dne'\n\\n\
directive.  Any extra symbols will be used to prefix the message.\n\
\n\
\n\
Pass line to output\n\
-------------------\n\
\n\
    #cppa outputline #define MYHOST Sunburn\n\
\n\
The output file will contain the line '#define MYHOST Sunburn'.\n\
(Normally, '#define' lines are not passed to the output files.)\n\
'#cppa notdirective' is equivalent to '#cppa outputline'.\n\
\n\
";

char help_hist1[] = "\n\
CPPA.C HISTORY\n\
==============\n\
\n\
This program was initially developed as a proposed replacement for GENVAR.\n\
which was used by CSD for generating some file variations.\n\
\n\
the following were considered...\n\
\n\
genvar version 2.x\n\
------------------\n\
    disadvantages:\n\
        not a standard unix utility.\n\
        macro substitution not implemented and difficult to implement.\n\
    advantages:\n\
        can generate multiple versions of a file in a single pass.\n\
        no makefile required.  self-sufficient one-step process.\n\
        easy to self-generate script.  (easy-to-add-feature: auto-execute.)\n\
        flexible customizable syntax.\n\
\n\
m4\n\
--\n\
    disadvantages:\n\
        unlike cpp, m4 is not familiar to many c programmers.\n\
        parentheses and commas are problematic if desired in the output.\n\
        lisp-ish syntax makes it difficult to avoid interaction between\n\
            directives and output lines.\n\
        can't concatenate macro with suffix.\n\
        presetting macros in m4 command line is a pain.\n\\n\
            normal method didn't work.  alternate is to do\n\
                echo '<preset>' | m4 - main.m4\n\
    advantages:\n\
        the 'recommended' generic macro processor that is standard with unix.\n\
        lisp-ish syntax makes it more flexible.\n\
\n\
";




char help_hist2[] = "\
cpp\n\
---\n\
    disadvantages:\n\
        can't expand macros within quotes.\n\
        produces excessive blank lines where directives occur.\n\
        can't concatenate macro with suffix.\n\
    advantages:\n\
        standard unix/c utility.\n\
        familiar to c programmers.\n\
        cpp directives highly visible with '#' prefixes.\n\
        little danger of mixing directives with output lines.        \n\
\n\
cpp plus cppa\n\
-------------\n\
    disadvantages:\n\
        in addition to standard unix/c utility, non-standard cppa required.\n\
        can't concatenate macro with suffix.\n\
    advantages:\n\
        cppa.c is a relatively simple add-on for cpp. \n\
        cppa.c can be re-written if needed or the source file can be modified\n\
            to avoid using it.  (but, source/dest files won't be as nice.)\n\
        most of the work is done by a standard unix/c utility.\n\
        familiar to c programmers.\n\
        cpp directives highly visible with '#' prefixes.\n\
        little danger of mixing directives with output lines.\n\
        additional features provided by cppa directives:\n\
            automatic makefile generation.\n\
            cppa comments.\n\
            do-not-edit directive.\n\
";



/******************************************************************************
main---
******************************************************************************/
main(int argc, char **argv) {

  char mode[LINE_CHARS_MAXCNT];

  argv++; argc--;

  if (! argc) {
    printf("\n%s\n\n", &rcs_id[9]);
    printf("%s", usage);
    exit(1);
  }

  strcpy(mode, *argv);
  argc--; argv++;

  if (! argc) {
    strcpy(cppafilename, "stdin");
    cppafile = stdin;
  }
  else {
    strcpy(cppafilename, *argv);
    if (! (cppafile = fopen(cppafilename, "r"))) {
      printf("FATAL PROGRAM ERROR: Could not open input file (%s).\n",
	     cppafilename);
      exit(18);
    }
  }
  Gil_Start(cppafile);

  if      STREQ(mode, "help") Help();
  else if STREQ(mode, "make") Make();
  else if STREQ(mode, "post") Post();
  else if STREQ(mode, "pre" ) Pre();
  else {
    fprintf(stderr,
            "Unrecognized option '%s'.  Use 'cppa' by itself for more info.",
            mode);
    exit(1);
  }
  exit(0);
}



/******************************************************************************
Get_Syms---
******************************************************************************/
int Get_Syms(char *source) {
  int sym_index;
  int cindex;
  char *source_ptr;

  /* Clear syma[] */
  {
    for (sym_index = 0; sym_index < LINE_SYMS_MAXCNT; sym_index++) {
      syma[sym_index][0] = '\0';
    }
  }

  source_ptr = source;
  sym_index = 0;

  while ((*source_ptr <= ' ') && (*source_ptr != '\0'))
    source_ptr++; /* Skip white space */

  while ((*source_ptr != '\0') &&
	 (sym_index < LINE_SYMS_MAXCNT)) {

    /* (More symbols to be loaded) */

    cindex = 0;
    while ((*source_ptr > ' '  ) &&      /* Not white space         */
	   (*source_ptr != '\0') &&      /* Not end of input string */
	   (cindex < SYM_CHARS_MAXCNT )) {
      syma[sym_index][cindex] = *source_ptr;
      cindex++;
      source_ptr++;
    }
    syma[sym_index][cindex] = '\0';

    while ((*source_ptr <= ' ') && (*source_ptr != '\0'))
      source_ptr++; /* Skip white space */

    if (debug>1) fprintf(stderr,
	          "SYMBOL %d LOADED (%s).\n", sym_index, syma[sym_index]);
    sym_index++;

  } /* (while more symbols to load) */

  return(sym_index);
}

/******************************************************************************
Help--- Print help information.
******************************************************************************/
Help() {
  printf("%s%s%s%s%s%s%s", 
	 rcs_id, help_1, help_2, help_3, help_addl, help_hist1, help_hist2);
}


/*+****************************************************************************
SEGFILETOP: caseshift.seg (This line must be the second line of the SEG.)
(Id: caseshift.seg,v 1.8 1993/09/03 23:29:51 albert Exp)
(Source: /local/src/sybase/segdir/RCS/caseshift.seg,v)

This file can be included into a C program at compile time (cpp/$include) or
using the seg program, or manually using your favorite text editor.
******************************************************************************/

/******************************************************************************
caseshift.seg: Shift_Down---
******************************************************************************/
Shift_Down(char *string) {
  int count, length;
  
  length = strlen (string);
  for (count = 0;  count < length;  count++) {
    if (isupper (string [count])) string [count] = tolower (string [count]);
  }
} /* Shift_Down */

/******************************************************************************
caseshift.seg: Shift_Up---
******************************************************************************/
Shift_Up(char *string) {
  int count, length;
  
  length = strlen (string);
  for (count = 0;  count < length;  count++) {
    if (islower (string [count])) string [count] = toupper (string [count]);
  }
} /* Shift_Up */

/******************************************************************************
caseshift.seg: Capitalize---

Capitalize the words in the string. A word is assumed to start
with the first alphabetic character which follows a stream
of punctuation marks known to ispunct() including space. 
******************************************************************************/
Capitalize(char *string) {
  int sindex, slength;

  slength=strlen(string)-1;
  if (islower(string[0])) string[0]=toupper(string[0]);

  for (sindex=0; sindex<slength; sindex++) {
    if ((ispunct(string[sindex]) || string[sindex]==' ') &&
        isalpha(string[sindex+1])) {
      /* First letter of symbol should be upper case. */
      if (islower(string[sindex+1]))
        string[sindex+1]=toupper(string[sindex+1]);
    }
    else {
      /* Non-first letter of symbol should be lower case. */
      if (isupper(string[sindex+1]))
        string[sindex+1]=tolower(string[sindex+1]);
    }
  }
}

/******************************************************************************
SEGFILEEND: caseshift.seg (This line must be the 2nd-to-last line of the SEG.)
**+***************************************************************************/

/*+****************************************************************************
SEGFILETOP: getline1.seg (This line must be the second line of the SEG.)
(Id: getline1.seg,v 1.21 1994/07/01 17:08:31 albert Exp)
(Source: /local/src/sybase/segdir/RCS/getline1.seg,v)

getline1 - simple/common version of the GetLine procedure.  (Without fancy
           comment-character and continuation-character processing.)

Users of this SEG file should also have caseshift.seg.
******************************************************************************/

#ifndef LINE_CHARS_MAXCNT
#define LINE_CHARS_MAXCNT 100
#endif

/******************************************************************************
getline1.seg: GetLine--- Read one line from the specified input file.

The module which includes this SEG may define the LINE_CHARS_MAXCNT constant.
(The number of elements in the gl_line character array parameter.)
A default value is provided otherwise.

The character that terminated the line, either '\n' or EOF, is not included
in the resultant string.

If no characters other than EOF are found in the input, FALSE is returned.

RETURN VALUE:
  \n  - If line was terminated by newline.       (TRUE)
  EOF - If line was terminated by EOF.           (TRUE)
  \0  - If EOF was first character encountered.  (FALSE)

PARAMETERS:
  *gl_file -- The file from which to read the line.
  *gl_line -- The character array into which to put the line.
  gl_mode  -- 0 => simple read,  
              1 => loud quit  if first symbol is "quit" or a prefix thereof.
              2 => quiet quit if first symbol is "quit" or a prefix thereof.
******************************************************************************/
int GetLine(char *gl_line, FILE *gl_file, int gl_mode) {
  /* $$$ NOTE: THE PARAMETER ORDER WAS CHANGED 6/30/94.  (FOR CONSISTENCY    */
  /* $$$ WITH Get_Data_Line and Get_User_Line.  AT THE SAME TIME, THIS       */
  /* $$$ FUNCTION WAS RENAMED FROM Get_Line to GetLine.                      */
  /* $$$ USERS OF THIS SEG FILE SHOULD BE ENCOURAGED TO USE Get_Data_Line or */
  /* $$$ Get_User_Line instead of Get_Line.                                  */
  int  gl_ret_val;
  char gl_symbol[120];
  int  gl_symbol_len;
  int  gl_line_cnt;
  int  gl_line_len;

	
  /*-------------------------------------------------------------------------*/

  /* Check parameters */
  {
    if (abs((int)gl_file) < 10) { /* Not a valid file pointer? */
      fprintf(segerr,
              "\n*** FATAL ERROR: BAD FIRST PARAMETER %d TO GetLine.\n",
              (int)gl_file);
      fprintf(segerr,"*** Please report this to action@cs.Stanford.EDU\n");
      exit(-14);
    }
    else if (abs((int) gl_line) < 10) { /* Not a valid string pointer? */
      fprintf(segerr,"\n*** FATAL ERROR: BAD SECOND PARAMETER TO GetLine.\n");
      fprintf(segerr,"*** Please report this to action@cs.Stanford.EDU\n");
      exit(-15);
    }
    else if ((gl_mode < 0) || (gl_mode > 2)) { /* Not a valid mode code? */
      fprintf(segerr,
              "\n*** FATAL ERROR: BAD THIRD PARAMETER %d TO GetLine.\n",
              gl_mode);
      fprintf(segerr,"*** Please report this to action@cs.Stanford.EDU\n");
      exit(-16);
    }
  }

  gl_line[0] = '\0'; /* In case we are at end of file. */

  fgets(gl_line, LINE_CHARS_MAXCNT, gl_file); 

  gl_line_cnt++;
  gl_line_len = strlen(gl_line);
  if (gl_line_len == 0) gl_ret_val = 0;/* End of file before GetLine started*/
  else if (gl_line[gl_line_len - 1] == '\n') { /* Terminated by newline. */
    gl_line[gl_line_len - 1] = '\0';           /* Remove the newline.    */
    gl_line_len--;                             /* Update line length.    */
    gl_ret_val = '\n';
  }
  else gl_ret_val = EOF; /* Terminated by EOF */

  if (gl_mode) {
    if (sscanf(gl_line, " %s", gl_symbol)) {
      Shift_Down(gl_symbol);
      gl_symbol_len = strlen(gl_symbol);
      if ((gl_symbol_len) &&
	  ((strncmp(gl_symbol, "quit",  gl_symbol_len) == NULL) ||
	   (strcmp( gl_symbol, "exit"                ) == NULL) ||
	   (strcmp (gl_symbol, "abort"               ) == NULL) ||
	   (strcmp (gl_symbol, "end"                 ) == NULL) )){
	if (gl_mode == 1) printf("Quitting.\n");
	exit(-17);
      }
    }
  }

  return( gl_ret_val);
}

/******************************************************************************
Get_User_Line--- Get a line of input from the user.
(Friendlier front end to GetLine().)
******************************************************************************/
int Get_User_Line(char *gl_line) {
  return GetLine(gl_line, stdin, 1);
}

/******************************************************************************
Get_Data_Line--- Get a line of input from a data file.
(Friendlier front end to GetLine().)
******************************************************************************/
int Get_Data_Line(char *gl_line, FILE *gl_file) {
  return GetLine(gl_line, gl_file, 0);
}

/******************************************************************************
SEGFILEEND: getline1.seg (This line must be the 2nd-to-last line of the SEG.)
**+***************************************************************************/


/*+****************************************************************************
SEGFILETOP: getinline.seg (This line must be the second line of the SEG.)
(Id: getinline.seg,v 1.8 1994/07/11 18:24:46 albert Exp)
(Source: /local/src/sybase/segdir/RCS/getinline.seg,v)

This seg file, when used along with getline1.seg, provides the ability to
read input from files which include "#include" directives.  It is being
implemented initially for use by cppa.c

This SEG file can be included into a C program in any of the following ways:
  1. Manually, using your favorite text editor.
  2. Automatically using the seg program.  (preferred)
     (Existing version of the SEG will be replaced with updated version.)
  3. At compile time, using the cpp "#include" directive.
See segdoc.seg for more information.
******************************************************************************/

#define GIL_FILES_MAX 16
static FILE *gil_file[GIL_FILES_MAX];
static int gil_current;

/* Forward declarations for private procedure */
int Gil_Got_Line();

/******************************************************************************
*::-> Gil_Start:::
Gil_Start--- Specify initial file for Get_In_Line() to use.
******************************************************************************/
Gil_Start(FILE *startfile) {

  gil_current = 0;
  gil_file[gil_current] = startfile;
}

/******************************************************************************
*::-> Gil_Get_Line_Line:::
Gil_Get_Line--- Read next line from gil_current input file.
  CASE 1: Normal line:  Pass the line back to the caller.
  CASE 2: "#include" line: update gil_file and get line from new current file
  CASE 3: End-of-file: update gil_file and get line from prev. current file
******************************************************************************/
int Gil_Get_Line(char *line) {
  int get_ret;
  int done;

  done = FALSE;
  while (!done) {
    get_ret = Get_Data_Line(line, gil_file[gil_current]);
    if (get_ret) {
      if (line[0] == '#') done = Gil_Got_Pound(line); /* CASE 1: '#' */
      else done = TRUE;                               /* CASE 2: Normal line */
    }
    else {
      if (gil_current) gil_current--;         /* CASE 3: End of include file */
      else done = TRUE;                       /* CASE 4: End of main file.   */
    }
  }
  return(get_ret);
}

/******************************************************************************
*::-> Gil_Get_Line::-> Gil_Got_Pound::
******************************************************************************/
int Gil_Got_Pound(char *line) {
  int got_ret;
  int ss_ret;
  char dsymbol[250];
  char fsymbol[250];

  got_ret = FALSE; /* Assume not done until proven otherwise. */
  ss_ret = sscanf(&line[1], " %s \"%s", dsymbol, fsymbol);
  if ((ss_ret != 2) || strcmp(dsymbol, "include")) 
    got_ret = TRUE; /* CASE 5: '#' but not '#include "<filename>"' */
  else {            /* CASE 6: '#include "<filename>"'             */
    fsymbol[strlen(fsymbol)-1] = '\0'; /* Trim trailing '\"' */
    gil_file[++gil_current] = fopen(fsymbol, "r");
    if (gil_file[gil_current] == NULL) {
      fprintf(segerr, "WARNING: Failed to open include file '%s'\n", fsymbol);
      gil_current--;
    }
  }
  return(got_ret);
}

/******************************************************************************
SEGFILEEND: getinline.seg (This line must be the 2nd-to-last line of the SEG.)
**+***************************************************************************/
