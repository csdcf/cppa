/******************************************************************************
cppa-pre.c -- This module of the cppa program handles 'pre' mode.
$Id: cppa-pre.c 2717 2011-06-20 17:49:43Z miles $
$Source$
******************************************************************************/
#include "cppa.h"

char dne_msg_wide[] = \
"D O   N O T   E D I T   T H I S   F I L E   D I R E C T L Y !";

char dne_msg_narrow[] = "DO NOT EDIT THIS FILE DIRECTLY!";

int sym_cnt, tf_directive, comment = FALSE;;

char line[LINE_CHARS_MAXCNT];

/******************************************************************************
Pre--- Handles shell command "cppa pre <cppafilename> > <cppfilename>

    Pre-process the text.
    1. Replace each non-directive quote with two quotes.
    2. Insert a ".DIRECTIVE" line before each cpp directive.
    3. Insert ".notdirective." in front of lines which begin with "#" but are 
       not cpp directives.
    4. Replace any lines with "#cppa dno" with the appropriate "Do Not Edit"
       line.
    5. Replace any "#cppa blank" with ".BLANK".
    6. Discard any lines which begin with "#cppa".  (These are directives to
       the cppa program and should not be passed to cpp.)
    7. Discard any lines between "#cppa comment" and "#cppa endcomment".
    8. Discard any lines between "#cppa makelines" and "#cppa endmakelines".
******************************************************************************/
Pre() {

  while (Gil_Get_Line(line)) {
    tf_directive = FALSE; /* Assume not a cpp directive until proven otherwise. */
    line[LINE_CHARS_MAXCNT - 1] = '\0';
    sym_cnt = Get_Syms(&line[1]);
    if ((line[0] == '#') && STREQ(syma[0], "cppa")) {
      Cppa_Directive();
    }
    else if (comment) {
      /* Discard this line which is part of a cppa comment (or makelines). */
    }
    else /* (Not a cppa directive and not part of a comment) */ {
      Not_Comment_Nor_Cppa_Directive();
    }
  } /* (while more lines) */
}


/******************************************************************************
Cppa_Directive--- Handle lines which start with "#cppa".
******************************************************************************/
Cppa_Directive() {

  if (debug) fprintf(stderr,"Cppa_Directive [%s]\n", syma[1]);
  if (STREQ(syma[1], "target"          ) ||
      STREQ(syma[1], "makeshowtarget"  ) ||
      STREQ(syma[1], "makenoshowtarget") ||
      STREQ(syma[1], "makeheader"      ) ||
      STREQ(syma[1], "maketopdep"      ) ||
      STREQ(syma[1], "maketopcmds"     ) ||
      STREQ(syma[1], "makemake"        ) ||
      STREQ(syma[1], "makebody"        )) {
    /* Discard cppa directives that affect "make" mode only */
  }
  else if (STREQ(syma[1], "outputline"  ) ||
           STREQ(syma[1], "notdirective") ){
    char *charptr;
    charptr = strstr(line, "outputline"); /* Find the outputline symbol.      */
    if (!charptr) charptr = strstr(line, "notdirective");
    charptr = strchr(charptr, ' ');       /* Find the following space, if any.*/
    if (charptr) {
      charptr++; /* The next character after the space. */
      printf(".notdirective.%s\n", charptr);
    }
    else {
      printf(".notdirective.\n");
    }
  }
  else if (STREQ(syma[1], "comment"     ) ||
           STREQ(syma[1], "makelines"   )) comment = TRUE;
  else if (STREQ(syma[1], "endcomment"  ) ||
           STREQ(syma[1], "endmakelines")) comment = FALSE;
  else if  STREQ(syma[1], "dne"       ) {
    if (debug) fprintf(stderr, "DNE SYMS (%d): (%s) (%s) (%s) (%s) (%s)\n",
                       sym_cnt, syma[1], syma[2], syma[3], syma[4], syma[5]);
    if STREQ(syma[2], "#") 
      strcpy(syma[2], ".notdirective.#");
    /* Insert "DO NOT EDIT" line as described in the dne directive */
    /* printf("# DEBUG: %s :DEBUG\n", dne_msg_wide); */
    if (sym_cnt > 2) printf("%s ", syma[2]);
    if (sym_cnt > 3) {
      printf("%s ", syma[3]);
      if (sym_cnt > 4) printf("%s ", syma[4]);
      if (sym_cnt > 5) printf("%s ", syma[5]);
      printf("%s", dne_msg_narrow);
    }
    else printf("%s", dne_msg_wide);
    printf("\n");
  }
  else if STREQ(syma[1], "blank") printf(".BLANK\n");
  else {
    fprintf(stderr, "FATAL ERROR: Unrecognized cppa directive (%s).\n", 
            syma[1]);
    exit(2);
  }
} /* (Cppa_Directive) */


/******************************************************************************
Not_Comment_Nor_Cppa_Directive---
******************************************************************************/
Not_Comment_Nor_Cppa_Directive() {
  char adjusted[LINE_CHARS_MAXCNT];
  int len, lindex, aindex;

  if (debug>1) fprintf(stderr,"# DEBUG2: '%s' :DEBUG2\n", syma[0]);
  if (line[0] == '#') {
    if (STREQ(syma[0], "define" ) ||
        STREQ(syma[0], "elif"   ) ||
        STREQ(syma[0], "else"   ) ||
        STREQ(syma[0], "endif"  ) ||
        STREQ(syma[0], "if"     ) ||
        STREQ(syma[0], "ifdef"  ) ||
        STREQ(syma[0], "ifndef" ) ||
        STREQ(syma[0], "include") ||
        STREQ(syma[0], "undef"  )) tf_directive = TRUE;
    else {
      strcpy(tempstr, line);
      strcpy(line, ".notdirective.");
      strcat(line, tempstr);
    }
  } /* # */
  
  if (tf_directive) printf(".DIRECTIVE\n%s\n",line);
  else {
    len = strlen(line);
    lindex = 0;
    aindex = 0;
    while (lindex < len) {
      if ((line[lindex] == '\"' ) || 
          (line[lindex] == '\'')) {
        adjusted[aindex++] = line[lindex];
        adjusted[aindex++] = line[lindex++];
      }
      else adjusted[aindex++] = line[lindex++];
    }
    adjusted[aindex++] = '\0';
    printf("%s\n", adjusted);
  } /* (else not tf_directive) */
} /* (Not_Comment_Nor_Cppa_Directive) */
